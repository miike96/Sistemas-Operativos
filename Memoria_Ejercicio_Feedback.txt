MEMORIA – Ejercicios de Feedback 1 (Sistemas Operativos – UAX)

Alumno: Miguel López Rodríguez
NP/Grupo: 0168912
Asignatura: Sistemas Operativos

==============================
ÍNDICE
==============================
1. Objetivos de la práctica
2. Entorno y requisitos
3. Ejercicio 1 – Diseño, implementación y resultados
4. Ejercicio 2 – Procesos e hilos: diseño y resultados
5. Ejercicio 3 – Planificación: cronograma y métricas
6. Conclusiones
7. Trabajo futuro
8. Bibliografía / Referencias
Anexos

==============================
1. OBJETIVOS DE LA PRÁCTICA
==============================
- Practicar programación en C con estructuras, arrays y funciones.
- Comprender y usar primitivas del sistema: procesos (fork, waitpid) y hebras (pthread).
- Analizar planificación de CPU (RR multinivel y FCFS por colas) y calcular tiempos.

==============================
2. ENTORNO Y REQUISITOS
==============================
- SO recomendado: Linux o WSL (Windows Subsystem for Linux).
- Compilador: gcc (C11). Librería pthread para hebras.
- Alternativa en Windows: MSYS2/MinGW (limitaciones con fork).

Comandos (Linux/WSL):
  sudo apt update && sudo apt install -y build-essential
  gcc -std=c11 -Wall -Wextra -O2 ej1.c -o ej1
  gcc -std=c11 -Wall -Wextra -O2 ej2.c -o ej2 -lpthread

Comandos (Windows MSYS2 MinGW64):
  pacman -Syu
  pacman -S --needed base-devel mingw-w64-x86_64-toolchain
  gcc -std=c11 -Wall -Wextra -O2 ej1.c -o ej1.exe
  gcc -std=c11 -Wall -Wextra -O2 ej2.c -o ej2.exe -lpthread

==============================
3. EJERCICIO 1 – DISEÑO, IMPLEMENTACIÓN Y RESULTADOS
==============================
3.1. Enunciado (resumen)
- Implementar estructura con array de 10 enteros y metadatos: tamaño y suma.
- Funciones: init, print, add, get size/sum, get element, set element, reset.
- Programa principal que demuestre los apartados del enunciado.

3.2. Diseño e implementación
- Estructura: arrayLength_t { arrInt[10]; arrSize; arrAdd }.
- Convención: -1 indica posición libre; valores válidos: >= 0.
- Inserción secuencial sin huecos; setElement sólo en posiciones ya ocupadas.
- Mantenimiento incremental de arrSize y arrAdd (O(1) en consultas).
- Función auxiliar recomputeSum() para auditoría y verificación.

3.3. Compilación y ejecución
- Ver sección 2 para comandos. Ejecución: ./ej1 (Linux/WSL) o ./ej1.exe (Windows).

3.4. Pruebas y resultados (salida real)
  {[0, 10, 20, 30, 40, 50, 60, 70, 80, 90], 10, 450}
  {[0, 1, 20, 3, 40, 5, 60, 7, 80, 9], 10, 225}
  {[0, 20, 40, 60, 80, 0, 1, 2, 3, 4], 10, 210}

3.5. Incidencias y decisiones
- Validación de índices y valores; gestión de errores por printf/return.
- Suma incoherente: usar recomputeSum() para verificación.

==============================
4. EJERCICIO 2 – PROCESOS E HILOS: DISEÑO Y RESULTADOS
==============================
4.1. Enunciado (resumen)
- Estructuras con base, exp y potencia. Calcular potencias con procesos e hilos.
- Mostrar arrays antes y después. Usar fork/waitpid y pthreads.

4.2. Diseño e implementación
- Cálculo iterativo de potencias (sin pow()).
- Procesos: cada hijo calcula base^exp y devuelve el resultado por exit (<=255). Nota: para valores mayores, usar pipes o memoria compartida.
- Hilos: cada hebra escribe su potencia directamente en el array compartido.
- Consideraciones de portabilidad: preferible Linux/WSL para fork.

4.3. Compilación y ejecución
- Ver sección 2. Ejecutar ./ej2 (Linux/WSL) o ./ej2.exe (Windows).

4.4. Pruebas y resultados (salida real)
Fragmento:
  arr1[0]: base: 0 exp: 2 potencia 0
  arr1[9]: base: 9 exp: 2 potencia 81
  arr2[0]: base: 0 exp: 2 potencia 0
  arr2[9]: base: 9 exp: 2 potencia 81

4.5. Incidencias y decisiones
- Límite del código de salida (8 bits) al devolver potencias vía exit.
- Enlazado de pthread (-lpthread) y entorno POSIX.

==============================
5. EJERCICIO 3 – PLANIFICACIÓN: CRONOGRAMA Y MÉTRICAS
==============================
5.1. Supuestos de planificación
- RR multinivel con cuantums: q1=2, q2=3, q3=4; democión por agotar quantum.
- Preempción por llegada a colas de mayor prioridad.
- PD realiza E/S: tras 1 u.t. de CPU, bloquea 2 u.t.
- Variante: prioridades fijas y FCFS por cola.

5.2. Cronograma (resumen)
- Incluir diagrama temporal o tabla por intervalos (adjuntar en Anexo si es largo).

5.3. Métricas (rellenar con cálculos)
- Tiempo de retorno (turnaround):
  PA = ____  PB = ____  PC = ____  PD = ____  PE = ____
- Tiempo de espera:
  PA = ____  PB = ____  PC = ____  PD = ____  PE = ____

5.4. Comentarios
- Comparación entre RR multinivel y FCFS por cola.
- Impacto de bloqueos de E/S (PD) en la planificación.

==============================
6. CONCLUSIONES
==============================
- Lecciones aprendidas sobre estructuras y mantenimiento de invariantes.
- Diferencias prácticas entre procesos e hilos y su coste.
- Efecto de la política de planificación en los tiempos de los procesos.

==============================
7. TRABAJO FUTURO
==============================
- Añadir eliminación/compactación en Ejercicio 1.
- Usar pipes/memoria compartida en Ejercicio 2 para resultados >255.
- Crear Makefile, pruebas unitarias y medición de tiempos.

==============================
8. BIBLIOGRAFÍA / REFERENCIAS
==============================
- man 2 fork, man 2 waitpid, man 3 pthread_create
- https://man7.org/linux/man-pages/
- Documentación de WSL y MSYS2/MinGW

==============================
ANEXOS
==============================
Anexo A – Salidas de ejecución (pegar capturas o texto)
  Salida ./ej1:
    {[0, 10, 20, 30, 40, 50, 60, 70, 80, 90], 10, 450}
    {[0, 1, 20, 3, 40, 5, 60, 7, 80, 9], 10, 225}
    {[0, 20, 40, 60, 80, 0, 1, 2, 3, 4], 10, 210}

  Salida ./ej2:
    arr1[0]: base: 1 exp: 0 potencia 1
    arr1[1]: base: 2 exp: 0 potencia 1
    arr1[2]: base: 3 exp: 0 potencia 1
    arr1[3]: base: 4 exp: 0 potencia 1
    arr1[4]: base: 5 exp: 0 potencia 1
    arr1[5]: base: 6 exp: 0 potencia 1
    arr1[6]: base: 7 exp: 0 potencia 1
    arr1[7]: base: 8 exp: 0 potencia 1
    arr1[8]: base: 9 exp: 0 potencia 1
    arr1[9]: base: 10 exp: 0 potencia 1
    arr1[0]: base: 0 exp: 2 potencia -1
    arr1[1]: base: 1 exp: 2 potencia -1
    arr1[2]: base: 2 exp: 2 potencia -1
    arr1[3]: base: 3 exp: 2 potencia -1
    arr1[4]: base: 4 exp: 2 potencia -1
    arr1[5]: base: 5 exp: 2 potencia -1
    arr1[6]: base: 6 exp: 2 potencia -1
    arr1[7]: base: 7 exp: 2 potencia -1
    arr1[8]: base: 8 exp: 2 potencia -1
    arr1[9]: base: 9 exp: 2 potencia -1
    arr1[0]: base: 0 exp: 2 potencia 0
    arr1[1]: base: 1 exp: 2 potencia 1
    arr1[2]: base: 2 exp: 2 potencia 4
    arr1[3]: base: 3 exp: 2 potencia 9
    arr1[4]: base: 4 exp: 2 potencia 16
    arr1[5]: base: 5 exp: 2 potencia 25
    arr1[6]: base: 6 exp: 2 potencia 36
    arr1[7]: base: 7 exp: 2 potencia 49
    arr1[8]: base: 8 exp: 2 potencia 64
    arr1[9]: base: 9 exp: 2 potencia 81
    arr2[0]: base: 1 exp: 0 potencia 1
    arr2[1]: base: 2 exp: 0 potencia 1
    arr2[2]: base: 3 exp: 0 potencia 1
    arr2[3]: base: 4 exp: 0 potencia 1
    arr2[4]: base: 5 exp: 0 potencia 1
    arr2[5]: base: 6 exp: 0 potencia 1
    arr2[6]: base: 7 exp: 0 potencia 1
    arr2[7]: base: 8 exp: 0 potencia 1
    arr2[8]: base: 9 exp: 0 potencia 1
    arr2[9]: base: 10 exp: 0 potencia 1
    arr2[0]: base: 0 exp: 2 potencia -1
    arr2[1]: base: 1 exp: 2 potencia -1
    arr2[2]: base: 2 exp: 2 potencia -1
    arr2[3]: base: 3 exp: 2 potencia -1
    arr2[4]: base: 4 exp: 2 potencia -1
    arr2[5]: base: 5 exp: 2 potencia -1
    arr2[6]: base: 6 exp: 2 potencia -1
    arr2[7]: base: 7 exp: 2 potencia -1
    arr2[8]: base: 8 exp: 2 potencia -1
    arr2[9]: base: 9 exp: 2 potencia -1
    arr2[0]: base: 0 exp: 2 potencia 0
    arr2[1]: base: 1 exp: 2 potencia 1
    arr2[2]: base: 2 exp: 2 potencia 4
    arr2[3]: base: 3 exp: 2 potencia 9
    arr2[4]: base: 4 exp: 2 potencia 16
    arr2[5]: base: 5 exp: 2 potencia 25
    arr2[6]: base: 6 exp: 2 potencia 36
    arr2[7]: base: 7 exp: 2 potencia 49
    arr2[8]: base: 8 exp: 2 potencia 64
    arr2[9]: base: 9 exp: 2 potencia 81

Anexo B – Código fuente o enlaces
  - ej1.c
  - ej2.c

Anexo C – Comandos utilizados
  [Listado de comandos usados para compilar y ejecutar]
